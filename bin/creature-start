#!/usr/bin/env node

const path = x => require("../" + x);
const immutable = path("js/immutable");

const commander = require("commander");
const program = new commander.Command();

const util = require("util");
const exec = util.promisify(require("child_process").exec);

program.parse(process.argv);

function setCurrentBranch(dp) {
  const cmd = "git rev-parse --abbrev-ref HEAD";
  return exec(cmd)
    .then(x => x.stdout.trim())
    .then(x => Object.assign({}, dp, { currentBranch: x }));
}

function setStandardBranches(dp) {
  return immutable.set(dp, "standardBranches", ["master", "release"]);
}

function validateCurrentBranch(dp) {
  if (!dp.standardBranches.includes(dp.currentBranch)) {
    throw `invalid base branch: ${dp.currentBranch}`;
  } else {
    return dp;
  }
}

function validateFeatureName(dp) {
  if (dp.standardBranches.includes(dp.featureName)) {
    throw `invalid feature branch: ${dp.featureName}`;
  } else {
    return dp;
  }
}

function setFeatureName(dp) {
  const fn = program.args.join("-");
  return Object.assign({}, dp, { featureName: fn });
}

function setPrefix(dp) {
  const p = process.env.FEATURE_USER || process.env.USER;
  return Object.assign({}, dp, { prefix: p });
}

function setFeatureBranch(dp) {
  const fb = `${dp.prefix}-${dp.currentBranch}-${dp.featureName}`;
  return Object.assign({}, dp, { featureBranch: fb });
}

function gitFetch(dp) {
  const cmd = "git fetch origin -p && git fetch origin --tags";
  console.log(cmd);
  return exec(cmd).then(x => dp);
}

function setMergeBranch(dp) {
  return immutable.set(
    dp,
    "mergeBranch",
    ["origin", dp.currentBranch].join("/")
  );
}

function gitMerge(dp) {
  const cmd = `git merge ${dp.mergeBranch}`;
  console.log(cmd);
  return exec(cmd).then(x => dp);
}

function gitBranch(dp) {
  const cmd = `git branch ${dp.featureBranch}`;
  console.log(cmd);
  return exec(cmd).then(x => dp);
}

function gitCheckout(dp) {
  const cmd = `git checkout ${dp.featureBranch}`;
  console.log(cmd);
  return exec(cmd).then(x => dp);
}

function gitPush(dp) {
  const cmd = `git push -u origin ${dp.featureBranch}`;
  console.log(cmd);
  return exec(cmd).then(x => dp);
}

function doit(dp) {
  const cmds = [
    "git fetch origin -p && git fetch origin --tags",
    `git merge ${dp.mergeBranch}`,
    `git branch ${dp.featureBranch}`,
    `git checkout ${dp.featureBranch}`,
    `git push -u origin ${dp.featureBranch}`
  ];
  return _.reduce(
    cmds,
    (accum, elem) => {
      console.log(elem);
      return accum
        .then(() => exec(elem))
        .then(x => {
          console.log("STDOUT", x.stdout);
          console.log("STDERR", x.stderr);
        });
    },
    Promise.resove({})
  );
}

function toPromise(dp) {
  return Promise.resolve(dp);
}

const x = toPromise({ program })
  .then(setStandardBranches)
  .then(setFeatureName)
  .then(validateFeatureName)
  .then(setPrefix)
  .then(setCurrentBranch)
  .then(validateCurrentBranch)
  .then(setFeatureBranch)
  .then(setMergeBranch)
  .then(doit)
  // .then(gitFetch)
  // .then(gitMerge)
  // .then(gitBranch)
  // .then(gitCheckout)
  // .then(gitPush)
  //  .then(x => console.log("x", x))
  .catch(err => console.error(err));
